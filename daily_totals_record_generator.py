from dataclasses import dataclass
from typing import List, Callable

import argparse
import csv
import datetime
import pathlib
import sys

from healthkit import HKRecordFactory, HK_APPLE_DATETIME_FORMAT
from healthdata import Fieldnames_DailyRecordTotals, FIELD_DATE, FIELD_UNIT, FIELD_VALUE
from utils import *


def serialize_summary_csv(csv_source_path: str,
                          csv_dest_path: str,
                          property: str,
                          device_predicate: Callable[[str], bool]):

    aggregator = DailyAggregator()
    unit = ''

    with open(csv_source_path) as rf:
        rdr = csv.DictReader(rf)

        try:
            row = next(rdr)
            unit = row['unit']
        except StopIteration:
            row = None

        while row is not None:
            hk_record = HKRecordFactory.create(row)
            if device_predicate(hk_record.device):
                start_date = datetime.datetime.strptime(hk_record.start_date, HK_APPLE_DATETIME_FORMAT)

                # calling astimezone() matches the local display of ios Health app records
                aggregator.add(start_date.astimezone(), hk_record.value)

            try:
                row = next(rdr)
            except StopIteration:
                row = None

    daily_totals = getattr(aggregator, property)

    with open(csv_dest_path, 'w', encoding='utf-8') as wf:
        wrtr = csv.DictWriter(wf, fieldnames=Fieldnames_DailyRecordTotals)
        wrtr.writeheader()
        keys = sorted(daily_totals.keys())

        for key in keys:
            wrtr.writerow({
                FIELD_DATE: key,
                FIELD_VALUE: daily_totals[key],
                FIELD_UNIT: unit
            })


@dataclass
class AggregatorConfiguration:
    filename: str
    property: str


configs: List[AggregatorConfiguration] = [
    AggregatorConfiguration('distance-walking-running.csv', 'sums'),
    AggregatorConfiguration('resting-heart-rate.csv', 'averages'),
    AggregatorConfiguration('step-count.csv', 'sums'),
    AggregatorConfiguration('body-mass.csv', 'averages'),
    AggregatorConfiguration('exercise-time.csv', 'sums'),
    AggregatorConfiguration('active-energy-burned.csv', 'sums'),
    AggregatorConfiguration('vo2max.csv', 'averages'),
    AggregatorConfiguration('waist-circumference.csv', 'averages'),
]


def gen_month_daily(month_path: str, device_predicate: Callable[[str], bool]):
    for config in configs:
        csv_source = f'{month_path}/{config.filename}'
        csv_dest = f'{month_path}/daily-totals-{config.filename}'
        serialize_summary_csv(csv_source, csv_dest, config.property, device_predicate)


def gen_lifetime_dailies(etl_path: str, device_predicate: Callable[[str], bool]):
    for month_path in pathlib.Path(etl_path).iterdir():
        print(f"Generating summaries in {month_path}")
        gen_month_daily(str(month_path), device_predicate)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog=pathlib.PurePath(__file__).name,
                                     description='generate daily summaries of HK_Record types.')

    parser.add_argument('-y', '--year', type=int, help='year of records to be loaded')
    parser.add_argument('-m', '--month', type=int, help='month of records to be loaded.')
    parser.add_argument('-w', '--watch-only', action='store_true',
                        help='process only data generated by or transmitted through Apple Watch')
    args = parser.parse_args()

    etl_path = f"{pathlib.Path.home()}/projects-data/apple-health/etl/monthly"
    device_predicate = watch_only if args.watch_only else always_true

    if args.month is None and args.year is None:
        gen_lifetime_dailies(etl_path, device_predicate)
    elif args.month is None or args.year is None:
        sys.exit(f"month argument is absent." if args.month is None else f"year argument is absent.")
    elif args.month < 1 or args.month > 12:
        sys.exit(f"{args.month} is not a valid month.")
    else:
        month_path = f"{etl_path}/{ymd_path_str(args.year, args.month)}"
        gen_month_daily(month_path, device_predicate)
